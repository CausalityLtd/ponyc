## Enhance runtime stats tracking

The current pony runtime stats tracking that was previously
implemented under the `USE_MEMTRACK` and `USED_MEMTRACK_MESSAGES`
defines has been enhanced. The new defines are called
`USE_RUNTIMESTATS` and `USE_RUNTIMESTATS_MESSAGES`.

Runtime stats tracking tracks the following actor info:
* heap memory allocated
* heap memory used
* heap num allocated
* heap realloc counter
* heap alloc counter
* heap free counter
* heap gc counter
* system message processing cpu usage
* app message processing cpu usage
* garbage collection cpu usage
* messages sent counter
* system messages processed counter
* app messages processed counter

Runtime tracking tracks the following scheduler info:
* mutemap memory used
* mutemap memory allocated
* memory used for gc acquire/release actormaps and actors created
* memory allocated for gc acquire/release actormaps and actors created
* created actors counter
* destroyed actors counter
* actor system message processing cpu for all actor runs on the scheduler
* actor app message processing cpu for all actor runs on the scheduler
* actor garbage collection cpu for all actor runs on the scheduler
* scheduler message processing cpu usage
* scheduler misc cpu usage while waiting to do work
* memory used by inflight messages
* memory allocated by inflight messages
* number of inflight messages

This runtime stats tracking info has been exposed to pony programs as
part of the `runtime_info` package and an example `runtime_info` program
has been added to the `examples` directory.

The runtime stats tracking in a pony program can be used for some
useful validations for those folks concerned about
heap allocations in the critical path (i.e. if they
rely on the compiler's `HeapToStack` optimization pass
to convert heap allocations to stack allocations and
want to validate it is working correctly).

Example of possible use to validate number of heap allocations:

```pony
use "collections"
use "runtime_info"

actor Main
  new create(env: Env) =>
    let num_allocs_before = ActorStats.heap_alloc_counter(ActorStatsAuth(env.root))

    let ret = critical()

    let num_allocs_after = ActorStats.heap_alloc_counter(ActorStatsAuth(env.root))

    env.out.print("Allocations before: " + num_allocs_before.string())
    env.out.print("Allocations after: " + num_allocs_after.string())

    env.out.print("Critical section allocated " + (num_allocs_after - num_allocs_before).string() + " heap objects")

    env.out.print("Allocations at end: " + ActorStats.heap_alloc_counter(ActorStatsAuth(env.root)).string())

  fun critical(): U32 =>
    var x: U32 = 1
    let y: U32 = 1000

    for i in Range[U32](1, y) do
      x = x * y
    end

    x
```
